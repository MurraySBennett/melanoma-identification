pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials[m] = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
rmse_desc
set.seed(1989)
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in 1:n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials[m] = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
trials
set.seed(1989)
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in 1:n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
rmse_desc
graphs_desc
order_error_desc
p_corr_desc
set.seed(1989)
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
rmse_desc
set.seed(1989)
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in n_sims){
print(m)
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
for (m in 1:n_sims){print(m)}
set.seed(1989)
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in 1:n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
set.seed(1989)
tic()
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in 1:n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
toc()
n_sims = 1000
items_max = 21
items_step= 10
n_items = seq(10, items_max, items_step)
mean_contests_per_pair = c(1, 5) #c(0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 15, 20)
sim_col_names = c("mu", "sd", "med", "se", "n_sims", "mean_ij_contests", "n_items", "trials", "iter")
r = length(n_items) * length(mean_contests_per_pair)
c = length(sim_col_names)
rmse_desc = data.frame(matrix(ncol=c, nrow=r, dimnames=list(NULL, sim_col_names)))
graphs_desc = rmse_desc
order_error_desc = rmse_desc
p_corr_desc = rmse_desc
n_sims = 100
items_max = 21
items_step= 10
n_items = seq(10, items_max, items_step)
mean_contests_per_pair = c(1, 5) #c(0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 15, 20)
sim_col_names = c("mu", "sd", "med", "se", "n_sims", "mean_ij_contests", "n_items", "trials", "iter")
r = length(n_items) * length(mean_contests_per_pair)
c = length(sim_col_names)
rmse_desc = data.frame(matrix(ncol=c, nrow=r, dimnames=list(NULL, sim_col_names)))
graphs_desc = rmse_desc
order_error_desc = rmse_desc
p_corr_desc = rmse_desc
n_sims = 1000
items_max = 21
items_step= 10
n_items = seq(10, items_max, items_step)
mean_contests_per_pair = c(1, 5) #c(0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 15, 20)
sim_col_names = c("mu", "sd", "med", "se", "n_sims", "mean_ij_contests", "n_items", "trials", "iter")
r = length(n_items) * length(mean_contests_per_pair)
c = length(sim_col_names)
rmse_desc = data.frame(matrix(ncol=c, nrow=r, dimnames=list(NULL, sim_col_names)))
graphs_desc = rmse_desc
order_error_desc = rmse_desc
p_corr_desc = rmse_desc
set.seed(1989)
tic()
sim_counter = 0
for (i in n_items){
for (c in mean_contests_per_pair){
contests <- rpois(n=i, lambda = c)
notzero <- contests > 0
Nmatrix <- Matrix(nrow = i, ncol = i)
ij <- which(lower.tri(Nmatrix), arr.ind = TRUE)[notzero, ]
Nmatrix <- sparseMatrix(
i = ij[, 1],
j = ij[, 2],
x = contests[notzero],
symmetric = TRUE,
dims = c(i, i))
## Generate at random the (normalized to mean 1) 'player abilities':
pi_vec <- exp(rnorm(i) / 4)
pi_vec <- pi_vec / mean(pi_vec)
## Now generate contest outcome counts from the Bradley-Terry model:
big_matrices <- simulate_BT(pi_vec, Nmatrix, nsim = n_sims, seed = 1)
for (m in 1:n_sims){
# print(sum(big_matrices[[m]]))
big_matrix <- big_matrices[[m]]
big_btdata <- btdata(big_matrix, return_graph = TRUE)
## Fit the Bradley-Terry model to the simulated data:
the_model <- btfit(big_btdata, a = 1)
pi_fitted <- the_model $ pi $ full_dataset
## calculate RMSE
actual = log(pi_vec[as.numeric(names(pi_fitted))])
predicted = log(pi_fitted)
predicted[is.infinite(predicted)] <- NA
# Metrics
rmse[m] = sqrt(mean((actual - predicted)^2, na.rm=TRUE))
trials = sum(big_matrix)
n_unique_graphs[m] = length(the_model$diagonal)
act_ordered = length(actual) - order(actual) + 1
pred_ordered= length(predicted) - order(predicted) + 1
order_err[m] = sqrt(mean((act_ordered - pred_ordered)^2, na.rm=TRUE))
p_corr[m] = cor(actual, predicted, method="pearson", use = "complete.obs")
# print(sprintf("RMSE: %s, n-trials: %s, unique graphs: %s, order error: %s, p-corr: %s", round(rmse,4), n_trials_simulated, n_unique_graphs, round(order_err,4), round(p_corr,4)))
}
sim_counter = sim_counter + 1
rmse_desc[sim_counter,] = c(get_desc(rmse), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
graphs_desc[sim_counter,] = c(get_desc(n_unique_graphs), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
order_error_desc[sim_counter,] = c(get_desc(order_err), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
p_corr_desc[sim_counter,] = c(get_desc(p_corr), return_sim_parms(n_sims, c, i, mean(trials), sim_counter))
}
}
toc()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
data <- data.frame(matrix(ncol=3, nrow=n_trials, dimnames=list(NULL, sim_col_names)))))
n_players <- 10
n_trials <- 10
players <- seq(1, n_players)
sim_col_names <- c("player1", "player2", "winner")
data <- data.frame(matrix(ncol=3, nrow=n_trials, dimnames=list(NULL, sim_col_names)))))
n_players <- 10
n_trials <- 10
players <- seq(1, n_players)
sim_col_names <- c("player1", "player2", "winner")
data <- data.frame(matrix(ncol=3, nrow=n_trials, dimnames=list(NULL, sim_col_names)))
view(data)
View(data)
players
sample(players, 5, replace=T)
sample(players, 10, replace=T)
a<-sample(players, 10, replace=T)
d <- matrix(a, nrow = 5, byrow = TRUE)
d
a
n_players <- 10
n_trials <- 10
players <- seq(1, n_players)
sim_col_names <- c("player1", "player2", "winner")
data <- data.frame(matrix(ncol=3, nrow=n_trials, dimnames=list(NULL, sim_col_names)))
get_contests <- function(p_list, trials){
players <- sample(p_list, trials * 2, replace = T)
contests <- matrix(players, nrow = trials, byrow = T)
return(contests)
}
data[, 1:2] <- get_contests(players, n_trials)
view(data)
data$player1 == data$player2
a<-data$player1 == data$player2
a
sum(a)
data[, a] <- sample(players, sum(a), replace=T)
view(data)
data[, 1:2] <- get_contests(players, n_trials)
view(data)
a<-data$player1 == data$player2
a
a[1] = TRUE
a
data[a,1] <- sample(players, sum(a), replace=T)
view(data)
a[c(1, 3, 5)] = TRUE
a
view(data)
data[a,1] <- sample(players, sum(a), replace=T)
view(data)
a <- TRUE
c = 0
while (a){}
while(a) {
c = c+1
if (c>= 5){ a =FALSE}
}
c
n_players <- 4
n_trials <- 10
players <- seq(1, n_players)
sim_col_names <- c("player1", "player2", "winner")
data <- data.frame(matrix(ncol=3, nrow=n_trials, dimnames=list(NULL, sim_col_names)))
get_contests <- function(p_list, trials){
players <- sample(p_list, trials * 2, replace = T)
contests <- matrix(players, nrow = trials, byrow = T)
no_mates <- contests[, 1] == contests[, 2]
while (sum(no_mates > 0)){
print(paste0("Number of players without friends: ", sum(no_mates)))
contests[no_mates, 1] <- sample(p_list, sum(no_mates), replace=T)
no_mates <- contests[, 1] == contests[, 2]
}
return(contests)
}
data[, 1:2] <- get_contests(players, n_trials)
view(data)
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("rstan", repos="https://cloud.r-project.org/", dependencies = TRUE)
example(stan_model, package = "rstsan", run.dontrun = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
Sys.getenv(MAKEFLAGS=paste0("-j", parallel::detectCores()))
install.packages(c("StanHeaders","rstan"),type="source")
example(stan_model, package="rstan", run.dontrun = TRUE)
stancode
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
library("rstan") # observe startup messages
rstan_options(auto_write = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
source("C:/Users/qlm573/melanoma-identification/feature-rating/btl-simulation/BTL-simulation.R")
source("C:/Users/qlm573/melanoma-identification/feature-rating/btl-simulation/BTL-simulation.R")
getwd()
setwd("C:Users/qlm573/melanoma-identification/feature-rating/btl-simulation")
setwd("C:Users/qlm573/melanoma-identification/feature-rating/btl-simulation")
setwd("C:Users/qlm573/melanoma-identification/feature-rating/)
")"
)
setwd("C:Users/qlm573/melanoma-identification/feature-rating")
setwd("C:/Users/qlm573/melanoma-identification/feature-rating/btl-simulation")
source("C:/Users/qlm573/melanoma-identification/feature-rating/btl-simulation/BTL-simulation.R")
source("C:/Users/qlm573/melanoma-identification/feature-rating/btl-simulation/BTL-simulation.R")
